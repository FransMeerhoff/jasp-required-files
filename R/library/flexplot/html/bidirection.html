<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Utilities for working with bidirecitonal layers</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for bidirection {flexplot}"><tr><td>bidirection {flexplot}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Utilities for working with bidirecitonal layers</h2>

<h3>Description</h3>

<p>These functions are what underpins the ability of certain geoms to work
automatically in both directions. See the *Extending ggplot2* for how they
are used when implementing 'Geom', 'Stat', and 'Position' classes.
</p>


<h3>Usage</h3>

<pre>
has_flipped_aes(data, params = list(), main_is_orthogonal = NA,
  range_is_orthogonal = NA, group_has_equal = FALSE,
  ambiguous = FALSE, main_is_continuous = FALSE)

flip_data(data, flip = NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>data</code></td>
<td>
<p>The layer data</p>
</td></tr>
<tr valign="top"><td><code>params</code></td>
<td>
<p>The parameters of the 'Stat'/'Geom'. Only the 'orientation'
parameter will be used.</p>
</td></tr>
<tr valign="top"><td><code>main_is_orthogonal</code></td>
<td>
<p>If only 'x' or 'y' are present do they correspond
to the main orientation or the reverse. E.g. If 'TRUE' and 'y' is present
it is not flipped. If 'NA' this check will be ignored.</p>
</td></tr>
<tr valign="top"><td><code>range_is_orthogonal</code></td>
<td>
<p>If 'xmin'/'xmax' or 'ymin'/'ymax' is present do
they correspond to the main orientation or reverse. If 'NA' this check will
be ignored.</p>
</td></tr>
<tr valign="top"><td><code>group_has_equal</code></td>
<td>
<p>Is it expected that grouped data has either a single
'x' or 'y' value that will correspond to the orientation.</p>
</td></tr>
<tr valign="top"><td><code>ambiguous</code></td>
<td>
<p>Is the layer ambiguous in its mapping by nature. If so, it
will only be flipped if 'params$orientation == &quot;y&quot;'</p>
</td></tr>
<tr valign="top"><td><code>main_is_continuous</code></td>
<td>
<p>If there is a discrete and continuous axis, does
the continuous one correspond to the main orientation?</p>
</td></tr>
<tr valign="top"><td><code>flip</code></td>
<td>
<p>Logical. Is the layer flipped.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'has_flipped_aes()' is used to sniff out the orientation of the layer from
the data. It has a range of arguments that can be used to finetune the
sniffing based on what the data should look like. 'flip_data()' will switch
the column names of the data so that it looks like x-oriented data.
'flipped_names()' provides a named list of aesthetic names that corresponds
to the orientation of the layer.
</p>


<h3>Value</h3>

<p>'has_flipped_aes()' returns 'TRUE' if it detects a layer in the other
orientation and 'FALSE' otherwise. 'flip_data()' will return the input
unchanged if 'flip = FALSE' and the data with flipped aesthetic names if
'flip = TRUE'. 'flipped_names()' returns a named list of strings. If
'flip = FALSE' the name of the element will correspond to the element, e.g.
'flipped_names(FALSE)$x == &quot;x&quot;' and if 'flip = TRUE' it will correspond to
the flipped name, e.g. 'flipped_names(FALSE)$x == &quot;y&quot;'
</p>


<h3>Controlling the sniffing</h3>

<p>How the layer data should be interpreted depends on its specific features.
'has_flipped_aes()' contains a range of flags for defining what certain
features in the data correspond to:
</p>
<p>- 'main_is_orthogonal': This argument controls how the existence of only a 'x'
or 'y' aesthetic is understood. If 'TRUE' then the exisiting aesthetic
would be then secondary axis. This behaviour is present in [stat_ydensity()]
and [stat_boxplot()]. If 'FALSE' then the exisiting aesthetic is the main
axis as seen in e.g. [stat_bin()], [geom_count()], and [stat_density()].
- 'range_is_orthogonal': This argument controls whether the existance of
range-like aesthetics (e.g. 'xmin' and 'xmax') represents the main or
secondary axis. If 'TRUE' then the range is given for the secondary axis as
seen in e.g. [geom_ribbon()] and [geom_linerange()]. 'FALSE' is less
prevalent but can be seen in [geom_bar()] where it may encode the span of
each bar.
- 'group_has_equal': This argument controls whether to test for equality of
all 'x' and 'y' values inside each group and set the main axis to the one
where all is equal. This test is only performed if 'TRUE', and only after
less computationally heavy tests has come up empty handed. Examples are
[stat_boxplot()] and [stat_ydensity]
- 'ambiguous': This argument tells the function that the layer, while
bidirectional, doesn't treat each axis differently. It will circumvent any
data based guessing and only take hint from the 'orientation' element in
'params'. If this is not present it will fall back to 'FALSE'. Examples are
[geom_line()] and [geom_area()]
- 'main_is_continuous': This argument controls how the test for discreteness
in the scales should be interpreted. If 'TRUE' then the main axis will be
the one which is not discrete-like. Conversely, if 'FALSE' the main axis
will be the discrete-like one. Examples of 'TRUE' is [stat_density()] and
[stat_bin()], while examples of 'FALSE' is [stat_ydensity()] and
[stat_boxplot()]
</p>

<hr /><div style="text-align: center;">[Package <em>flexplot</em> version 0.8.8 <a href="00Index.html">Index</a>]</div>
</body></html>
